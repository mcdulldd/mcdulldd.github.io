<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cookie和session]]></title>
    <url>%2Fposts%2F5a451c70.html</url>
    <content type="text"><![CDATA[cookieCookie是访问某些网站以后在本地存储的一些网站相关的信息，下次再访问的时候减少一些步骤。Cookie中一般包含如下主要内容：key：设置cookie的keyvalue：key对应的valuemax_age/expire_time：设置cookie的过期时间domain：该cookie在哪个域名中生效。一般设置子域名，比如cms.example.compath: 该cookie在哪个路径下生效例如，我们在登录某一个网站时需要输入用户名和密码，如果用户名和密码保存为cookie，则下次我们登录该网站的时候就不需要再次输入用户密码了。sessionsession是存在服务器的一种用来存放用户数据的类HashTable结构。浏览器第一次发生请求的时候，服务器自动生成了一个HashTable和一个SessionID来唯一标识这个HashTable，并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的SessionID放在请求中一并发送到服务器上，服务器从请求中提取SessionID，并和保存的所有SessionID进行对比，找到用户对应的HashTable。例如，我们浏览一个购物网站，用户将部分商品添加到购物车中，许久以前许多网站都是用服务端session存储购物车内容（现在基本都是用数据库），就用到了session存储这部分信息区别存储位置不同cookie的数据信息存放在本地session的数据信息存放在服务器上存储容量大小不同cookie存储的容量较小，一般&lt;=4kbsession存储容量大小没有限制，但是为了服务器性能考虑，一般不能存放太多数据存储有效期不同cookie可以长期存储，只要不超过设置的过期时间，可以一直存储。session在超过一定的操作时间，通常为30分钟，会失效，但是当关闭浏览器时，为了保护用户信息，会自动调用session.invalidate()方法，清除session中的信息。安全性不同cookie存储在客户端，所以可以分析存放在本地cookie并进行cookie欺骗，安全性较低。session存储在服务器上，不存在敏感信息泄露的风险，安全性较高。域支持范围不同cookie支持跨域名访问。例如：所有的a.com的cookie在a.com下都能用。session不支持跨域名访问。例如：www.a.com的session在api.a.com下不能用对服务器压力不同cookie保存在客户端，不占用服务器资源。session是保存在服务器端，每个用户都会产生一个session，session过多的时候会消耗服务器资源，所以大型网站会有专门的session服务器。存储的数据类型不同cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或二进制数据。session中能够存储任何类型的数据，包括且不限于string,integer,list,map等。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道面试题引发的思考]]></title>
    <url>%2Fposts%2F85aa51e5.html</url>
    <content type="text"><![CDATA[起因昨天在群里看到一个小伙伴问了一道面试题，题目如下：1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125; var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;; obj.method(fn, 1);我一看不就考察this指向吗，简单。然后就被打脸了。。。arguments先看结果：首先打印的是10，如果不明白可以参考重学JS之this里的this部分。然后打印出2，说实话看到这个结果我是一脸懵逼的，于是我打印了下this的指向结果指向Arguments，经过一番搜索得出：每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。Arguments对象介绍Arguments的length属性Argumentsd的length属性，表示function函数实际所传参数的个数。函数名.length可以获取函数期望传参的个数。1234567891011121314151617function argNum(a, b, c) &#123; console.log(arguments.length);&#125;console.log(argNum.length) // 3// 需要注意的是，形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数function argNum(a, b, c = 1) &#123; console.log(arguments.length);&#125;console.log(argNum.length) // 2// arguments.length 是函数被调用时实际传参的个数。function argNum(a, b, c) &#123; console.log(arguments.length);&#125;argNum() // 0argNum(1, 2, 3) // 3Arguments的参数访问Arguments对象的参数访问可以用arguments[i]来访问函数所传的参数。12345678910function argTest(a,b,c)&#123; var arg = []; for(var i = 0; i &lt; arguments.length; i++)&#123; arg.push(arguments[i]); &#125; console.log(arg);&#125;argTest(11, 12); // [11, 12]argTest(11, 12, 13); // [11, 12, 13]argTest(11, 12, 13, 14); // [11, 12, 13, 14]Arguments的callee调用Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。12345function argTest(a,b,c)&#123; var e = arguments.callee.toString(); console.log(e);&#125;argTest(); //打印出函数本身Function对象caller属性Function对象的caller属性可以指向当前函数的调用者，当调用者函数正在执行时才可调用，1234567891011121314151617function callerTest()&#123; if(callerTest.caller)&#123; var caller = callerTest.caller.toString(); console.log(caller); &#125;else&#123; console.log("no caller") &#125;&#125;function handler()&#123; callerTest();&#125;function handlerToHandler()&#123; handler();&#125;callerTest(); // no callerhandler(); // 返回调用者handler函数handlerToHandler(); // 返回调用者handler函数Arguments的作用方法重载方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。Javascript并没有重载函数的功能，但是Arguments对象能够模拟重载。12345678910function test(...nums)&#123; var sum = 0; for(var i = 0; i &lt; nums.length; i++)&#123; sum += nums[i]; &#125; console.log(sum);&#125;test(); // 0test(11, 12); // 23test(11, 12, 13); // 36递归调用这样的好处就是可以实现匿名函数的递归调用。123456789function factorial(n)&#123; if(n == 1)&#123; return 1; &#125;else&#123; n * arguments.callee(n-1); &#125;&#125;factorial(1); //1factorial(5); //120不定参数问题1234567891011function max()&#123; var maxNum = Number.NEGATIVE_INFINITY;; for(var i = 0; i &lt; arguments.length; i++)&#123; if(arguments[i]&gt; maxNum)&#123; maxNum = arguments[i]; &#125; &#125; return maxNum;&#125;max(1, 2, 3, 11, 4, 10); // 11max(2, -10, 22, 11); // 22]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>arguments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新JS之Promise、模块化与浏览器模型]]></title>
    <url>%2Fposts%2Fb9e286bb.html</url>
    <content type="text"><![CDATA[Promise在前端开发的过程中最让人头疼是就是处理异步请求的情况，在请求成功回调函数里继续写函数，最终形成回调地狱：12345678910111213function load() &#123; $.ajax(&#123; url: 'xxx.com', data: 'jsonp', success: function(res) &#123; init(res, function(res) &#123; render(res, function(res) &#123; // 形成回调地狱 &#125;); &#125;); &#125; &#125;&#125;于是Promise应运而生。Promise对象用于表示一个异步操作的最终完成 (或失败), 及其结果值，是异步编程的一种解决办法。Promise对象有两个特点1、对象的状态不受外界影响。Promise有三种状态：pending：初始状态，既不是成功也不是失败状态；fulfilled：操作成功完成；rejected：操作失败。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态。2、一旦状态改变就不会再变。Promise状态的改变只有两种情况：pending——&gt;fulfilledpending——&gt;rejected基本语法Promise是一个构造函数，用来生成一个Promise实例12345const promise = new Promise((resolve, reject) =&gt; &#123; // 做一些异步操作，做种调用下面两者之一 reslove(); // 变为fulfilled状态 reject(); // 变为rejected状态&#125;)方法Promise.all()批量执行Promise.all()用于将多个promise实例包装成一个新的Promise实例，返回的实例就是普通的Promise。他接受一个数组作为参数，数组里可以是Promise对象也可以是别的值，只有Promise会等待状态改变。当所有的子Promise都完成，该Promise完成，返回全部值的数组，有任何一个失败，该Promise失败，返回值是第一个失败的子Promise结果。举个栗子：123456789var p1 = Promise.resolve(3);var p2 = 1337;var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'foo');&#125;); Promise.all([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // [3, 1337, "foo"] &#125;);Promise.race()类似于Promise.all()，区别在于它有任意一个完成就算完成123456789var p1 = Promise.resolve(3);var p2 = 1337;var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'foo');&#125;); Promise.race([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // 3&#125;);Promise原型Promise.prototype.catch()添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise;当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果;Promise.prototype.then()添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve;Promise.prototype.finally()添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象,回调会在当前promise运行完毕后被调用。手写Promise12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// promise三个状态：pending(等待)、resolved(完成)、rejected(拒绝)const PENDING = 'pending';const RESOLVED = 'resolved';const REJECTED = 'rejected';// 简易Promisefunction MyPromise(fn) &#123; const self = this; self.state = PENDING; self.value = null; self.resolvedCallbacks = []; self.rejectedCallbacks = []; // 完成方法 function resolve(value) &#123; if(self.state===PENDING) &#123; self.state = RESOLVED; self.value = value; self.resolvedCallbacks.map(cb =&gt; cb(self.value)); &#125; &#125; // 拒绝方法 function reject(value) &#123; if(self.state === PENDING) &#123; self.state = REJECTED; self.value = value; self.rejectedCallbacks.map(cb =&gt; cb(self.value)); &#125; &#125; // 执行传入的方法 try &#123; fn(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;// then方法MyPromise.prototype.then = function(success, error) &#123; const self = this; success = typeof success === 'function' ? success : v =&gt; &#123; return v; &#125;; error = typeof error === 'function' ? error : r =&gt; &#123; throw r; &#125;; if(self.state === PENDING) &#123; self.resolvedCallbacks.push(success); self.rejectedCallbacks.push(error); &#125; if(self.state === RESOLVED) &#123; success(self.value); &#125; if(self.state === REJECTED) &#123; error(self.value) &#125;&#125;// 执行自定义Promisenew MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(100); &#125;, 3000)&#125;).then(value =&gt; &#123; console.log(value);&#125;, error =&gt; &#123; console.log(error);&#125;)模块化无模块化随着前端js代码复杂度提高，我们开始引入多个js文件，而不是把所有js代码写在一个文件中。优点：相比于使用一个js文件，有了很大进步；缺点：污染全局作用域，依赖关系不明显，后期维护成本高。CommonJS规范CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。如下所示：123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX;优点：CommonJS规范在服务器端率先完成了js模块化，解决了依赖、全局变量污染的问题。缺点：由CommonJS是同步加载模块的，对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了。AMD规范MD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。优点：适合在浏览器环境中异步加载模块，可以并行加载多个模块。缺点：提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。CMD规范CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。优点：同样实现了浏览器端的模块化加载；可以按需加载，依赖就近。缺点：依赖SPM打包，模块的加载逻辑偏重。ES6模块化在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。123456789101112// math.jsvar basicNum = 0;var add = function(a, b) &#123; return a + b;&#125;export &#123; basicNum, add &#125;;// 引入模块import &#123; basicNum, add &#125; from './math'function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125;浏览器事件模型一个事件发生后，会在子元素和父元素之间传播，分成三个阶段：捕获阶段：事件从window兑现自上而下向目标节点传播的阶段；目标阶段：真正的目标节点正在处理事件的阶段；冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。冒泡事件12345678910111213&lt;div id="s1"&gt;s1 &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;s1.addEventListener("click", function(e)&#123; console.log("s1 冒泡事件");&#125;, false);s2.addEventListener("click", function(e)&#123; console.log("s2 冒泡事件"); // e.stopPropagation() 阻止事件冒泡&#125;, false);&lt;/script&gt;// 点击s2输出：s2冒泡 s1冒泡事件捕获12345678910111213&lt;div id="s1"&gt;s1 &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt; s1.addEventListener("click", function(e)&#123; // e.stopPropagation(); 阻止事件捕获 console.log("s1 捕获事件"); &#125;, true); s2.addEventListener("click", function(e)&#123; console.log("s2 捕获事件"); &#125;, true);&lt;/script&gt;// 点击s2输出：s1捕获事件 s2捕获事件阻止事件默认行为1234567891011121314&lt;p&gt;Please click on the checkbox control.&lt;/p&gt;&lt;form&gt; &lt;label for="id-checkbox"&gt;Checkbox:&lt;/label&gt; &lt;input type="checkbox" id="id-checkbox"/&gt;&lt;/form&gt;&lt;div id="output-box"&gt;&lt;/div&gt;&lt;script&gt;document.querySelector("#id-checkbox").addEventListener("click", function(event) &#123; document.getElementById("output-box").innerHTML += "Sorry! &lt;code&gt;preventDefault()&lt;/code&gt; won't let you check this!&lt;br&gt;"; // 阻止默认行为 event.preventDefault();&#125;, false);&lt;/script&gt;]]></content>
      <categories>
        <category>重学JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
        <tag>模块化</tag>
        <tag>浏览器模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学JS之ES6]]></title>
    <url>%2Fposts%2Fe60f250e.html</url>
    <content type="text"><![CDATA[ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，适应更复杂的应用，实现代码库之间的共享，不断迭代维护新版本。比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。var、let和const的区别1、var声明的变量会提升到作用域的顶部，而let和const不会进行提升2、var声明的全局变量会被挂在到全局window对象上，而let和const不会3、var可以重复声明同一个变量，而let和const不可以4、var声明的变量的作用域范围是函数作用域，而let和const声明的变量范围是块级作用域5、const声明的常量，一旦声明就不能再次赋值，再次赋值会报错，但是更改对象属性不会，因为对象地址没有改变作用域提升：1234567console.log(a); // 输出undefinedconsole.log(b); // 报错console.log(PI); // 报错var a = 'abc';let b = 'ABC';const PI = 3.1415;挂载到全局变量上：1234567var a = 'abc';let b = 'ABC';const PI = 3.1415;console.log(window.a); // 输出abcconsole.log(window.b); // 输出undefinedconsole.log(window.PI); // 输出undefined重复声明变量：123456var a = 'abc';var a;console.log(a); // 输出abclet b = 'ABC';let b;// 报错变量的作用域范围：123456789101112function foo() &#123; var flag = true; if(flag) &#123; var a = 'abc'; let b = 'ABC'; console.log(a); // 输出abc console.log(b); // 输出ABC &#125; console.log(a); // 输出abc console.log(b); // 报错&#125;foo();const常量：12const PI = 3.1415;PI = 3.1415926; // 报错扩展/收缩符这是ES6新增加的运算符...，称为扩展或者收缩，具体作用取决于如何使用1234567891011121314151617181920// ...的扩展function foo(x,y,z) &#123; console.log(x,y,z); // 输出1,2,3&#125;var arr = [1,2,3];foo(...arr); // 扩展数组：ES6写法foo.apply(null,arr); // 扩展数组：ES5写法// ...的收缩// 收集参数：ES6写法function bar(...arr) &#123; console.log(arr); // 输出[1,2,3,4,5]&#125;// 收集参数：ES5写法function foo()&#123; var args = Array.prototype.slice.call(arguments); console.log(args); // 输出[1,2,3,4,5]&#125;bar(1,2,3,4,5);foo(1,2,3,4,5)解构赋值常用的解构赋值，有如下两种情况“1、对象的解构2、数组的解构1234567891011121314151617181920212223242526272829// 常用解构方式:解构对象 or 解构数组// ES6之前的获取返回数组和返回对象的方式function foo() &#123; return [1,2,3];&#125;function bar() &#123; return &#123; X: 4, Y: 5, Z: 6 &#125;&#125;var arr = foo();var a = arr[0];var b = arr[1];var c = arr[2];var obj = bar();var x = obj.X;var y = obj.Y;var z = obj.Z;console.log(a,b,c); // 输出1,2,3console.log(x,y,z); // 输出4,5,6// ES6之后获取返回数组和返回对象的方式var [A,B,C] = foo();var &#123;X,Y,Z&#125; = bar();console.log(A,B,c); // 输出1,2,3console.log(X,Y,Z); // 输出4,5,6字符串模板${内容}字符串模板的内容可以是变量、函数调用以及表达式1234567891011// 字符串模板var name = 'Lisa';// ES5拼接字符串var str = '你好，我是' + name;// ES6模板字符串var newStr = `你好，我是$&#123;name&#125;`;console.log(str); // 你好，我是Lisaconsole.log(newStr); // 你好，我是Lisa箭头函数ES6中的新特性，通过参数 =&gt; 函数体的方式调用。特性：1、没有this、super、arguments、new target绑定。this、super、arguments、以及内部函数的new target的值由所在的最近的外部非箭头函数来决定2、不能使用new来调用。箭头函数没有[[Construct]]方法，因此不能被用为构造函数，使用new调用函数会抛出错误3、没有原型。没有使用new，因此没有prototype属性4、不能修改this绑定。不能通过call()、bind()以及apply()方法修改this5、没有arguments对象。需要通过命名参数和不定参数这两种形式访问函数的参数6、不允许使用重复的具名函数。箭头函数不允许拥有重复的具名函数，无论是否在严格模式下举个栗子：123456789101112131415161718192021222324252627// ES5var sum = function(num1, num2)&#123; return num1 + num2;&#125; // ES6let sum = (num1, num2) =&gt; num1 + num2;// ES5 var person = function(name) &#123; return &#123; getName: function() &#123; return name; &#125; &#125;&#125;('Lisa')console.log(person.getName()); // Lisa// ES6let person = ((name) =&gt; &#123; return &#123; getName: function() &#123; return name; &#125; &#125;&#125;)('Andy')console.log(person.getName()) ; // Andymap和set结构Map结构对象是创建无序键值对数据结构映射的主要机制，在ES6之前，对象的属性只能是字符串，在ES6之后，Map结构允许使用对象、数组等作为键。12345678910111213141516171819202122232425262728293031323334353637// Map结构var map = new Map();var x = &#123; id: 1 &#125;, y = &#123; id: 2 &#125;;// 设置map数据map.set(x,'bar');map.set(y,'foo');// 获取map数据console.log(map.get(x)); // 输出barconsole.log(map.get(y)); // 输出foo// 获取map结构的长度console.log(map.size); // 输出2// 根据指定键删除map数据map.delete(x);// 根据指定的键判断是否存在于map结构中console.log(map.has(x)); // 输出false// 遍历map键for(var key of map.keys()) &#123; console.log(key); // 输出&#123;id:2&#125;&#125;// 遍历map值for(var value of map.values()) &#123; console.log(value); // 输出foo&#125;// 遍历map键值对for(var item of map.entries()) &#123; console.log(item[0]); // &#123;id:1&#125; &#123;id:2&#125; console.log(item[1]); // bar foo &#125;Set结构123456789101112131415161718192021222324252627282930313233343536373839// Set结构var set = new Set();var x = &#123; id: 1 &#125;;var y = &#123; id: 2 &#125;;var a = 1;var b = "1";var c = true// 添加Set数据set.add(x);set.add(y);set.add(a);set.add(b);set.add(c);// 获取Set数据的长度console.log(set.size); // 输出5// 删除Set数据set.delete(c);// 判断某个值是否存在Set结构中console.log(set.has(c));// 输出false// 遍历Set的键for(var key of set.keys()) &#123; console.log(key); // 输出&#123;id：1&#125; &#123;id:2&#125; 1 "1"&#125;// 遍历Set的值for(var value of set.values()) &#123; console.log(value); // 输出&#123;id:1&#125; &#123;id:2&#125; 1 "1"&#125;// 遍历Set的键值对for(var item of set.entries()) &#123; console.log(item[0]); // 输出 &#123;id:1&#125; &#123;id:2&#125; 1 "1" console.log(item[1]); // 输出 &#123;id:1&#125; &#123;id:2&#125; 1 "1"&#125;Set结构的扩展1234567891011121314151617181920// Set集合的运用：数组的去重、并集、交集、差集var arr1 = [1,2,1,3,4,5];var arr2 = [4,5,6,7];// 去重：输出1,2,3,4,5console.log(Array.from(new Set(arr1)));// 并集：输出1,2,3,4,5,6,7var union = Array.from(new Set([...set1,...set2]));console.log(union); // 交集：输出4,5var intec = Array.from(new Set(arr.filter(x =&gt; arr1.includes(x))));console.log(intec);// 差集var diff1 = Array.from(new Set(arr1.filter(x =&gt; !arr2.includes(x))));var diff2 = Array.from(new Set(arr2.filter(x =&gt; !arr1.includes(x))));console.log(diff1); // 输出：1,2,3console.log(diff2); // 输出：6,7Proxy在Vue2.0+的版本中，Vue使用Object.definedProperty()方法来实现数据的响应式，在Vue3.0的开发计划中，作者计划使用ES6新增加的Proxy代理来实现数据的响应式，它相比于Object.definedProperty()有如下几个特点：1、Proxy可以一次性为所有属性实现代理，无需遍历，性能更佳2、Proxy能监听到以前使用Object.definedProperty()监听不到的数据变动。3、由于是ES6新增加的特性，所以浏览器兼容性方面比Object.definedProperty()差123456789101112131415161718192021let onWatch = function(obj,setBind, getLogger) &#123; return new Proxy(obj, &#123; get(target, property, receiver) &#123; getLogger(target, property); return Reflect.get(target, property, receiver); &#125;, set(target, property, value, receiver) &#123; setBind(value, property); return Reflect.set(target, property, value); &#125; &#125;)&#125;let obj = &#123; a: 1&#125;let p = onWatch(obj, (value, property) =&gt; &#123; console.log(`监听到$&#123;property&#125;属性的改变，其值为$&#123;value&#125;`)&#125;, (target, property) =&gt; &#123; console.log(`监听到获取属性$&#123;property&#125;,其值为$&#123;target[property]&#125;`)&#125;)p.a = 2; // 监听到a属性的改变，其值为2console.log(a); // 监听到获取属性a,其值为2map、filter和reduce的区别map方法的作用是生成一个新数组(把原数组中的所有元素做一些变动，放进新数组中)12var newArr = [1,2,3].map(v =&gt; v*2);console.log(newArr); // 输出[2,4,6];filter： filter方法的作用是从原数组中过滤出符合条件的元素，并生成一个新数组12var newArr = [1,2,3,4,5,6].filter(item =&gt; item%2==0);console.log(newArr); // 输出[2,4,6];reduce方法的作用是通过回调函数的形式，把原数组中的元素最终转换成一个值，第一个参数是回调函数，第二个参数是初始值12345var arr = [1,2,3,4,5,6];var sum = arr.reduce((account, current) =&gt; &#123; return account + current;&#125;, 0);console.log(sum); // 21]]></content>
      <categories>
        <category>重学JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学JS之面向对象、原型链和继承]]></title>
    <url>%2Fposts%2F496dc878.html</url>
    <content type="text"><![CDATA[面向对象JavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript’s existing prototype-based inheritance. The class syntax does not introduce a new object-oriented inheritance model to JavaScript.js里面是没有“类”，js的面向对象，还是基于原型的，无论是ES5还是ES6，ES6中引入的class只是基于原型继承的语法糖创建对象的方法new操作符+Object创建对象1234567var person = new Object();person.name = 'zhangsan';person.age = 21;person.family = ['lisi', 'wangwu'];person.say = function() &#123; alert(this.name)&#125;字面式创建对象12345678var person = &#123; name: "lisi", age: 21, family: ["lida","lier","wangwu"], say: function()&#123; alert(this.name); &#125;&#125;工厂模式以上两种方法在使用同一接口创建多个对象时，会产生大量重复代码，为了解决此问题，工厂模式被开发。12345678910function person() &#123; var o = new Object(); o.name = name; o.age = age; o.family = family; o.say = function()&#123; alert(this.name); &#125; return o;&#125;构造函数模式工厂模式虽然解决了重复实例化多个对象的问题，但是工厂模式却无从识别对象的类型，因为全部都是Object，不像Date、Array等，本例中，得到的都是o对象，对象的类型都是Object，因此出现了构造函数模式。123456789function Person(name,age,family) &#123; this.name = name; this.age = age; this.family = family; this.say = function()&#123; alert(this.name); &#125;&#125;var person1 = new Person("lisi",21,["lida","lier","wangwu"]);跟工厂模式相比：1、没有显式地创建对象2、直接将属性和方法赋给了 this 对象3、没有 return 语句原型模式构造函数内的方法在做同一件事，但是实例化后却产生了不同的对象，因此产生了原型模式。12345678function Person() &#123;&#125;Person.prototype.name = "lisi";Person.prototype.age = 21;Person.prototype.family = ["lida","lier","wangwu"];Person.prototype.say = function()&#123; alert(this.name);&#125;;var person = new Person();混合模式（构造函数模式+原型模式）构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性123456789101112131 function Person(name,age,family)&#123; 2 this.name = name; 3 this.age = age; 4 this.family = family; 5 &#125; 6 7 Person.prototype = &#123; 8 constructor: Person, 9 say: function()&#123;10 alert(this.name);11 &#125;12 &#125; var person = new Person("lisi",21,["lida","lier","wangwu"]);混合模式共享着对相同方法的引用，又保证了每个实例有自己的私有属性。最大限度的节省了内存原型链利用js原型模型，代码读取某个对象的某个属性时，都会按照属性名执行一次搜索,在实例中找到了则返回，如果没有找到，则继续在当前实例的原型对象中搜索，直到找到为止，如果还没有找到，则继续该原型对象的原型对象，以此类推，直到搜索到Object对象为止，这样就形成了与各原型指向的链条，专业术语称之为原型链。继承在ES6之前，实现继承需要依赖原型、原型链和构造函数等等技术手段组合使用，在ES6之后，可以使用class类继承(并没有真正的类，只是一个语法糖，实质依然是函数)继承的几种方式原型链实现继承通过重写子类的原型，并将它指向父类的手段实现。这种方式实现的继承，创建出来的实例既是子类的实例，又是父类的实例。它有如下几种缺陷：1、不能向父类构造函数传参2、父类上的引用类型属性会被所有实例共享，其中一个实例改变时，会影响其他实例12345678910111213141516function Animal() &#123; this.colors = ['red','blue'];&#125;function Dog(name) &#123; this.name = name;&#125;Dog.prototype = new Animal();var dog1 = new Dog('旺财');var dog2 = new Dog('钢镚');dog2.colors.push('yellow');console.log(dog1.colors); // ["red", "blue", "yellow"]console.log(dog2.colors); // ["red", "blue", "yellow"]console.log(dog1 instanceof Dog); // trueconsole.log(dog1 instanceof Animal);// true借用构造函数实现继承借用构造函数实现继承，通过在子类中使用call()方法，实现借用父类构造函数并向父类构造函数传参的目的。但这种方法，无法继承父类原型对象上的属性和方法。1234567891011121314151617181920function Animal(name) &#123; this.name = name; this.colors = ['red','blue'];&#125;Animal.prototype.eat = function() &#123; console.log(this.name + ' is eating!');&#125;function Dog(name) &#123; Animal.call(this,name);&#125;var dog1 = new Dog('旺财');var dog2 = new Dog('钢镚');dog2.colors.push('yellow');console.log(dog1.colors); // ["red", "blue"]console.log(dog2.colors); // ["red", "blue", "yellow"]console.log(dog1 instanceof Dog); // trueconsole.log(dog2 instanceof Animal);// falseconsole.log(dog1.eat()); // 报错组合继承组合继承是组合了原型链继承和借用构造函数继承这两种方法，它保留了两种继承方式的优点，但它并不是百分百完美的：父类构造函数被调用多次。1234567891011121314151617function Animal(name) &#123; this.name = name; this.colors = ['red','blue'];&#125;Animal.prototype.eat = function() &#123; console.log(this.name + ' is eatting');&#125;function Dog(name) &#123; Animal.call(this,name);&#125;Dog.prototype = new Animal(); // 第一次调用var dog1 = new Dog('dog1'); // 第二次调用var dog2 = new Dog('dog2'); // 第三次调用dog1.colors.push('yellow');console.log(dog1.name); // 输出dog1console.log(dog2.colors);// 输出['red','blue']console.log(dog2.eat()); // 输出dog2 is eatting寄生组合继承寄生组合继承是在组合继承的基础上，采用Object.create()方法来改造实现123456789101112131415161718function Animal(name) &#123; this.name = name; this.colors = ['red','blue'];&#125;Animal.prototype.eat = function() &#123; console.log(this.name + ' is eatting');&#125;function Dog(name) &#123; Animal.call(this,name);&#125;Dog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;var dog1 = new Dog('dog1');var dog2 = new Dog('dog2');dog1.colors.push('yellow');console.log(dog1.name); // 输出dog1console.log(dog2.colors);// 输出['red','blue']console.log(dog2.eat()); // 输出dog2 is eattingClass类实现继承1234567891011121314151617181920class Animal &#123; constructor(name) &#123; this.name = name; this.colors = ['red','blue']; &#125; eat() &#123; console.log(this.name + ' is eatting'); &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); &#125;&#125;var dog1 = new Dog('dog1');var dog2 = new Dog('dog2');dog1.colors.push('yellow');console.log(dog1.name); // 输出dog1console.log(dog2.colors);// 输出['red','blue']console.log(dog2.eat()); // 输出dog2 is eatting]]></content>
      <categories>
        <category>重学JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
        <tag>原型链</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学JS之作用域、闭包与this]]></title>
    <url>%2Fposts%2F72c80684.html</url>
    <content type="text"><![CDATA[作用域作用域就是根据名称来查找变量的一套规则。js中有全局作用域、局部作用域，es6中又添加了块级作用域。作用域最大的用途就是隔离变量或者函数，并控制它们的生命周期。作用域是在函数执行上下文创建时定义好的，不是函数执行时定义。举个栗子：123456789101112131415161718192021222324252627282930function a() &#123; return function b() &#123; var str = 'b'; console.log(str); &#125;&#125;function c() &#123; var str = 'c'; b();&#125;var b = a();c() // b// 去掉函数b里面的str声明function a() &#123; return function b() &#123; // var str = 'b'; console.log(str); &#125;&#125;function c() &#123; var str = 'c'; b();&#125;var b = a();c() // 报错 str is not undefined全局作用域JavaScript has two scopes: global and local.A variable that is declared outside a function definition is a global variable, and its value is accessible and modifiable throughout your program.A variable that is declared inside a function definition is local.It is created and destroyed every time the function is executed, and it cannot be accessed by any code outside the function.JavaScript does not support block scope (in which a set of braces {. . .} defines a new scope), except in the special case of block-scoped variables.任何地方都能访问到的对象拥有全局作用域。函数外面定义的变量拥有全局作用域，未定义直接赋值的变量自动声明为拥有全局作用域，以及window对象的属性拥有全局作用123456789var n = 2;function fn() &#123; var a = 1; return n + a;&#125;console.log(fn()) // 3console.log(n) // 2console.log(a) // 报错console.log(window.name) // name是window对象的属性局部作用域局部作用域一般只在固定的代码片段内可以访问，最常见的如函数内部，所以一些地方会把这种作用域称为函数作用域。在上面的例子中，变量a是函数fn()内部声明并赋值，拥有局部作用域，只能在函数内部使用，在函数外部使用就会报错。块级作用域ES6引入了块级作用域，明确允许在块级作用域中声明函数，let和const命令都涉及块级作用域。块级作用域允许声明函数只在使用大括号的情况下成立，如果未使用大括号，会报错。123456if(true) &#123; function fn1()&#123;&#125; // 不报错&#125;if(true) function fn2()&#123;&#125; // 报错作用域链当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。在当前函数中如果js引擎无法找到某个变量，就会往上一级嵌套的作用域中去寻找，直到找到该变量或抵达全局作用域，这样的链式关系就称为作用域链。123456789101112131415var a = 1;function fn() &#123; var a = 10; function fn1() &#123; var a = 20; console.log(a); &#125; function fn2() &#123; console.log(a); &#125; fn1(); // 20 fn2(); // 10 &#125;fn();console.log(a) // 1闭包当一个函数能够记住并访问它所在的词法作用域的时候，就产生了闭包，即使函数式在词法作用域之外执行闭包的几种形式1、 返回一个函数2、 作为函数参数传递3、 回调函数4、 非典型闭包IIFE(立即执行函数表达式)返回一个函数：这种形式的闭包在JavaScript的代码编写中，是非常常见的一种方式。1234567891011var a = 1;function foo()&#123; var a = 2; // 这就是闭包 return function()&#123; console.log(a); &#125;&#125;var bar = foo();// 输出2，而不是1bar();作为函数参数传递：无论通过何种手段将内部函数传递到它所在词法作用域之外，它都会持有对原始作用域的引用，无论在何处执行这个函数，都会产生闭包。1234567891011121314var a = 1;function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; // 这就是闭包 fn();&#125;// 输出2，而不是1foo();回调函数：在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。123456789// 定时器setTimeout(function timeHandler()&#123; console.log('timer');&#125;，100)// 事件监听$('#container').click(function()&#123; console.log('DOM Listener');&#125;)IIFE：IIFE(立即执行函数表达式)并不是一个典型的闭包，但它确实创建了一个闭包。12345var a = 2;(function IIFE()&#123; // 输出2 console.log(a);&#125;)();thisJavaScript中的this只有如下几种情况1、对于直接调用的函数来说，不管函数被放在了什么地方，this都是window2、对于被别人调用的函数来说，被谁调用，this就是谁3、在构造函数中，类(函数体)中出现的this.xxx = xxx中的this是当前类中的一个实例4、call、apply时，this是第一个参数，bind要优于call\apply5、箭头函数没有自己的this，需要看其外层的是否有函数，如果有，外层函数的this就睡内部箭头函数的this，如果没有，则this就是window]]></content>
      <categories>
        <category>重学JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
        <tag>作用域</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1像素边框实现]]></title>
    <url>%2Fposts%2Ff8951cb6.html</url>
    <content type="text"><![CDATA[产生原因在移动端开发中，经常需要在html的header里添加如下一句：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;这句话定义了本页面的viewport的宽度为设备宽度，初始缩放值和最大缩放值都是1，并禁止了用户缩放。在window对象中有一个devicePixelRatio属性，他可以反应css中的像素与设备的像素比。然而1px在不同的移动设备上都等于这个移动设备的1px，这是因为不同的移动设备有不同的像素密度。即：devicePixelRatio = 物理像素 / 独立像素所以，1px会变粗的原是，viewport的设置和屏幕物理分辨率是按比例而不是相同的.解决方案利用设备像素比缩放，设置小数像素1234567.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125;设置border-image不管是border-image还是background-image，图片的弊端还是很明显的：想改变颜色就必须要换图片，而且利用图片也比较麻烦。所以不推荐这种方案。12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url("border.png") 2 0 stretch; border-image: url("border.png") 2 0 stretch;&#125;background-image渐变实现与background-image方案类似，只是将图片替换为css3渐变。12345678910.border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px;&#125;transform-scale(0.5)把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。123456789101112131415161718192021222324252627div &#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125;div::after&#123; content:'';width:100%; border-bottom:1px solid #000; transform: scaleY(0.5);&#125;.div::after &#123; content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); -webkit-transform-origin: top left;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见CSS示例]]></title>
    <url>%2Fposts%2Fed7c3b5e.html</url>
    <content type="text"><![CDATA[在实际开发过程中，经常要解决 一些样式问题，下面记录一些常见的样式，便于以后的开发。居中问题水平居中DOM结构:123&lt;div class='container'&gt; &lt;div class='item'&gt;Hello World&lt;/div&gt; &lt;/div&gt;实现方法：12345678910111213141516171819202122232425/* 使用text-align:center */.container &#123; text-align: center;&#125;/* 设置margin为auto */ .item &#123; margin: auto;&#125;/* 使用flex布局,添加justify-content属性 */ .container &#123; display: flex; justify-content: center;&#125;/* 绝对定位 */ .container &#123; position: relative;&#125;.item &#123; position: absolution; left: 50%; transform: translateX(-50%);&#125;垂直居中DOM结构：123&lt;div class='container'&gt; &lt;div class='item'&gt;Hello World&lt;/div&gt; &lt;/div&gt;实现方法：12345678910111213141516171819202122232425262728/* 设置line-height为父容器的高度 */.container &#123; height: 80px; line-height: 80px;&#125;/* flex布局使用align-item实现 */.container &#123; display: flex; align-iten: center;&#125;/* 绝对定位 */.container &#123; position: relative;&#125;.item &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125;/* 使用table-cell*/.container &#123; display: table-cell; vertical-align: middle;&#125;圆HTML部分：1&lt;div class='circle'&gt;&lt;/div&gt;CSS实现部分12345678910111213141516171819202122232425262728293031/* 正圆 */.circle &#123; width: 100px; height: 100px; background: #be4141; border-radius: 50%;&#125;/* 椭圆 */.circle &#123; width: 200px; height: 100px; background: #be4141; border-radius: 50%;&#125;/* 半椭圆 */.circle &#123; width: 100px; height: 100px; background: #be4141; border-radius: 50% 50% 0 0 / 100% 100% 0 0;&#125;/* 四分之一椭圆 */.circle &#123; width: 200px; height: 100px; background: #be4141; border-radius: 100% 0 0 0;&#125;三角形HTML部分：12345678&lt;!-- 三角形 --&gt;&lt;div class='triangle'&gt;&lt;/div&gt;&lt;!-- 气泡 --&gt;&lt;div class="bubble"&gt; &lt;div class="triangle common"&gt;&lt;/div&gt; &lt;div class="cover common"&gt;&lt;/div&gt; &lt;/div&gt;CSS部分：1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 上三角形 */.triangle &#123; width: 0; height: 0; border-top: 50px solid transparent; border-bottom: 50px solid #be4141; border-right: 50px solid transparent; border-left: 50px solid transparent;&#125;/* 斜三角 */.triangle &#123; width: 0; height: 0; border-top: 50px solid #be4141; border-right: 50px solid transparent;&#125;/* 气泡 */.bubble &#123; width: 200px; height: 50px; border: 5px solid #be4141; position: relative;&#125;.common &#123; width: 0; height: 0; position: absolute; left: 50%; transform: translate(-50%, 0); &#125;.triangle &#123; bottom: -20px; border-top: 20px solid #be4141; border-right: 20px solid transparent; border-left: 20px solid transparent;&#125;.cover &#123; bottom: -13px; border-top: 20px solid #be4141; border-right: 20px solid transparent; border-left: 20px solid transparent;&#125;动画加载动画1&lt;div class="loading"&gt;&lt;/div&gt;动画实现：123456789101112131415161718@keyframes loading-animation &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg) &#125;&#125;.loading &#123; width: 50px; height: 50px; display: inline-block; border: 5px solid #ccc; border-left-color: #be4141; border-radius: 50%; animation: loding-animation 1.2s liner infinite;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的几种常见方法]]></title>
    <url>%2Fposts%2Fbabf57c4.html</url>
    <content type="text"><![CDATA[在文档流中，如果没有给父元素设置宽高时，父元素的宽高会被子元素撑开。但是当子元素设置浮动属性后，子元素会溢出到父元素外，父元素的宽高也不会被撑开，这种现象被称为“高度塌陷”。如下图所示：123456789101112131415161718&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .container&#123; border: 4px solid #8990D5; zoom: 1; &#125; .div1, .div2 &#123; float: left; height: 100px; width: 100px; text-align: center; background-color: #FFB5BF; &#125;&lt;/style&gt;解决这个问题便是要清除浮动，在下面我们给出了几种常规解决方案。1、通过添加额外标签，利用clear属性来清除浮动1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div class=&apos;clear&apos;&gt;&lt;/div&gt;&lt;/div&gt; &lt;style&gt;.clear &#123; clear: both;&#125;&lt;/style&gt;2、使用br标签br自带clear属性，clear属性有left、right和all三个属性值可选12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box_1 float&quot;&gt;box 1&lt;/div&gt; &lt;div class=&quot;box_2 float&quot;&gt;box 2&lt;/div&gt; &lt;br clear=&quot;all&quot;&gt;&lt;/br&gt;&lt;/div&gt;3、给父元素设置overflow123456789101112&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div2&lt;/div&gt;&lt;/div&gt; &lt;style&gt;.container &#123; overflow: hidden; border: 4px solid #8990D5; zoom: 1;&#125;&lt;/style&gt;4、使用伪元素after12345678910111213141516171819&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div class=&apos;clear&apos;&gt;&lt;/div&gt;&lt;/div&gt; &lt;style&gt;.container::after &#123; content: &apos;&apos;; clear: both; display: block; height: 0; visibility: hidden;&#125;.container &#123; border: 4px solid #8990D5; zoom: 1;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《CSS揭秘》读书笔记]]></title>
    <url>%2Fposts%2Fb652aa0.html</url>
    <content type="text"><![CDATA[笔记内容在: https://pocketdou.top/CSS-Tricks/]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2Fposts%2Fb0f8c1e6.html</url>
    <content type="text"><![CDATA[在仿写去哪儿网的过程中遇到了父子组件通信和兄弟组件通信的情况，今天整理下在vue中组件间通信的情况。vue中组件通信一般分为以下几种情况：父子组件通信兄弟组件通信跨多级组件通信任意组件父子组件通信父组件通过props传递数据给子组件，子组件通过emit发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。这种父子通信方式也就是典型的单向数据流，父组件通过props传递数据，子组件不能直接修改props，而是必须通过发送事件的方式告知父组件修改数据。另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 默认会解析成名为 value 的 prop 和名为 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。当然我们还可以通过访问 $parent 或者 $children对象来访问组件实例中的方法和数据。兄弟组件通信对于这种情况可以通过查找父组件中的子组件实现，也就是this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。PS: 组件name的作用：1、做递归组件 2、页面取消缓存 3、组件名跨多级组件通信使用provide / inject,示例：1234567891011121314// 父组件 Aexport default &#123; provide: &#123; data: 1 &#125;&#125;// 子组件 Bexport default &#123; inject: ['data'], mounted() &#123; // 无论跨几层都能获得父组件的 data 属性 console.log(this.data) // =&gt; 1 &#125;&#125;任意组件这种情况下可以通过 Vuex 或者 Event Bus 解决]]></content>
      <categories>
        <category>VUE</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2Fposts%2F62faf33d.html</url>
    <content type="text"><![CDATA[1、页面导入样式时，使用link和@import有什么区别？从属关系：link属于XHTML，link除了加载CSS，还可以定义RSS，定义rel连接属性等；@import是CSS提供的语法规则，只能加载CSS加载顺序：link会随页面被同时加载，@import需要等页面加载完再加载兼容性：link没有兼容性问题，@import需要IE5及其以上才能被识别操作DOM：link可以通过js操作DOM动态引入样式表改变样式，而@import不可以2、圣杯布局和双飞翼布局的理解和区别，并用代码实现相同点：圣杯布局和双飞翼布局都是三栏全部float浮动，左右两栏加上-margin让其与中间栏并排，形成三栏布局。不同点：解决中间div不被遮挡的思路不同。圣杯布局是将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。双飞翼布局通过多加一个 div 并使用了 margin 来实现，圣杯布局则是使用 padding、相对定位（relative）、设置偏移量（left、right）来实现，相对来说，双飞翼布局更容易理解。在圣杯布局中，无限缩小屏幕（假设没有设置 body 的最小宽度），当 .main 的宽度小于 .left 时，会出现布局错乱。圣杯布局：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;style&gt; .wrapper &#123; height: 300px; padding: 0 200px; overflow: hidden; &#125; .wrapper .left &#123; width: 200px; height: 100px; background: blue; float: left; position: relative; left: -200px; margin-left: -100%; &#125; .wrapper .right &#123; width: 200px; background: #ccc; height: 100px; float: right; position: relative; right: -200px; margin-left: -100%; &#125; .wrapper .center &#123; background: yellow; width: 100%; height: 100%; float: left; &#125; .center, .left, .right &#123; padding-bottom: 9999px; margin-bottom: -9999px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;双飞翼布局：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;style&gt; .wrapper &#123; height: 300px; overflow: hidden; &#125; .wrapper .left &#123; width: 200px; height: 100px; background: blue; float: left; /*position: relative; left: -200px; */ margin-left: -100%; &#125; .wrapper .right &#123; width: 200px; background: #ccc; height: 100px; float: left; /*position: relative; right: -200px; */ margin-left: -200px; &#125; .wrapper .center &#123; background: yellow; width: 100%; height: 100%; float: left; &#125; .center .inner &#123; /* * 这是圣杯和双飞翼最明显的区别 * 在main内部使用的是margin,而圣杯是直接在container部分使用padding */ margin-left: 200px; margin-right: 200px; &#125; .center, .left, .right &#123; padding-bottom: 9999px; margin-bottom: -9999px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="center"&gt; &lt;div class="inner"&gt; center &lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt; left &lt;/div&gt; &lt;div class="right"&gt; right &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;参考：You-need-to-know-css3、用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值12345678910111213141516function randomArray(arr, len) &#123; // 获取2-32的随机数 let num = Math.floor(Math.random() * 31 + 2) // 判断数组长度 if (arr.length === len) &#123; return arr &#125; // indexOf用于返回某个指定的字符串值在字符串中首次出现的位置，若没有返回-1 if (arr.indexOf(num) &gt; -1) &#123; return randomArray(arr, len) &#125; else &#123; arr.push(num) return randomArray(arr, len) &#125;&#125;console.log(randomArray([], 5))4、html的元素有哪些（包含H5）？区分出行内元素、块级元素、空元素123行内元素：label a b i em span td input button strong块级元素：div p h1 ul li ol oi dl dt dd table nav menu section article haeder footer aside form 空元素：br hr img5、CSS3有哪些新增的特性选择器：1234子元素选择器&gt;相邻兄弟选择器+ 通用兄弟选择器~ 群组选择器,边框与圆角：123border-radius 圆角box-shadow 盒阴影 border-image 边框图像背景与渐变：12345background-size 背景图片的尺寸background_origin 背景图片的定位区域background-clip 背景图片的绘制区域linear-gradient 线性渐变radial-gradient 径向渐变文本与字体：1234567word-breakword-wraptext-overflowtext-shadowtext-wraptext-outlinetext-justify2D转换：12transformtransform-origin2D转换方法：123456789translate(x,y)translateX(n)translateY(n)rotate(angle)scale(n)scaleX(n)scaleY(n)rotate(angle)matrix(n,n,n,n,n,n)3D转换：123transformtransform-origintransform-style3D转换方法：12345678910111213translate3d(x,y,z)translateX(x)translateY(y)translateZ(z)scale3d(x,y,z)scaleX(x)scaleY(y)scaleZ(z)rotate3d(x,y,z,angle)rotateX(x)rotateY(y)rotateZ(z)perspective(n)过渡：1transition动画：12@Keyframes规则animation6、写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉左、右、两边和全部的空格123456789101112131415161718192021222324function deleSpac(str, direction) &#123; let Reg = ''; switch (direction) &#123; case 'left': Reg = /^[\s]+/g; break; case 'right': Reg = /([\s]*)$/g; break; case 'both': Reg = /(^\s*)|(\s*$)/g break; default: Reg = /[\s]+/g; break; &#125; let newStr = str.replace(Reg, ''); if (direction == 'middle') &#123; let RegLeft = str.match(/(^\s*)/g)[0]; let RegRight = str.match(/(\s*$)/g)[0]; newStr = RegLeft + newStr + RegRight; &#125; return newStr;&#125;7、在页面上隐藏元素的方法有哪些？并简述出第一种方法的应用场景和优劣势。123456789101112dispaly:none设置为dispaly:none的元素将不会再占用页面空间，其占用的空间会被其他元素所占有从而会引起浏览器的重排和重绘。visibility:hidden这种做法虽然能够隐藏元素，但是该元素仍会占用页面空间,因此只会导致浏览器的重绘而不会引起重排。如果希望元素隐藏后不会引起页面布局的变化，则推荐使用visibility:hidden;方式。opacity:0将元素透明度设置为0，与visibility:hidden效果一样，同样占据页面空间z-index:-9999改变元素的堆叠顺来隐藏元素margin-left:-100%将元素移出页面8、HTML5的文件离线储存怎么使用，工作原理是什么？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源；123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html3、在离线状态时，操作window.applicationCache进行需求实现。参考：丶King的博客园9、去除字符串中最后一个指定的字符123456789101112function del(str, tar) &#123; // 判断是否为字符串 if (typeof str !== 'string') &#123; return false &#125; else &#123; // 获取最后一个指定字符串的位置 let index = str.lastIndexOf(tar) // 删除指定字符串 str = str.substr(0, index) + str.substr(index + tar.length) console.log(str) &#125;&#125;10、写一个方法把下划线命名转成大驼峰命名1234567function toCamel(str)&#123; if(typeof str !== 'string')&#123; return false &#125;else&#123; str = str.split('_').map(item=&gt;item.charAt(0).toUpperCase()+item.substr(1,item.length)).join('') &#125;&#125;11、简述超链接target属性的取值和作用target这个属性指定所链接的页面在浏览器窗口中的打开方式。它的参数值主要有：_blank ：在新浏览器窗口中打开链接文件_parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件_self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。_top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。12、写一个把字符串大小写切换的方法1234567891011function caseConvert(str) &#123;// 将字符串分隔 let sp = str.split(''); str = sp.map(item =&gt; &#123; if (item.charCodeAt() &lt;= 90) &#123; return item.toLowerCase() &#125; else &#123; return item.toUpperCase() &#125; &#125;).join('')&#125;13、label都有哪些作用？label标签通常是写在form表单内，它通常关联一个控件;它有两个属性，一个是for，一个是accesskey。for功能：表示这个Lable是为哪个控件服务的，Label标签要绑定了for指定HTML元素的ID或name属性，你点击这个标签的时候，所绑定的元素将获取焦点 ，点击label所包裹内容，自动指向for指定的id或name示例：12&lt;label for="man"&gt;Female&lt;/label&gt;&lt;input type="radio" name="sex" id="man" /&gt;accesskey则定义了访问这个控件的热键示例：12// Alt+C跳转到百度&lt;a href="http://www.baidu.com" accesskey="c"&gt;百度&lt;/a&gt;14、用css创建一个三角形1234567891011&lt;style type="text/css"&gt;.square &#123; width: 0; height: 0; border: 30px solid transparent; border-top: 30px solid red;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="square"&gt;&lt;/div&gt;&lt;/body&gt;15、iframe框架都有哪些优缺点？优点：重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，加快了网页下载速度)技术易于掌握，使用方便，使用者众多，可主要应用于不需搜索引擎来搜索的页面方便制作导航栏缺点：搜索引擎程序不能解读这种页面浏览器的后退按钮无效手机等终端设备无法显示全部框架内容16、统计某一字符或字符串在另一个字符串中出现的次数412345678function strCount(str,tar)&#123; let count = 0 while(str.includes(tar))&#123; count++ str = str.replace(tar, '') &#125; return count&#125;17、清除浮动的方式有哪些及优缺点添加div空标签清除浮动clear:both优点：通俗易懂，容易掌握缺点：添加很多无意义的空标签，后期难以维护父级div定义overflow:hidden优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏父级div定义伪类:after和zoom(用于非IE浏览器)优点：浏览器支持好缺点：代码量多父级div定义height优点：简单、代码少、容易掌握缺点：只适合高度固定的布局父级div定义overflow:auto必须定义width或zoom:1，同时不能定义height优点：简单，代码少，浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条。18、简述下你理解的优雅降级和渐进增强优雅降级：一开始对一个高版本的浏览器构建页面，先完善所有功能，然后针对不同的浏览器进行修复，以高版本为基础，向下兼容。渐进增强：一开始对一个低版本的浏览器构建页面，再针对高版本的浏览器进行各种功能效果的追加，以实现最基础的功能为基本，向上兼容。19、简要描述下什么是回调函数回调函数就是将函数作为一个参数传到另一个函数里面，当那个函数执行完之后，再执行传递进去的这个函数。举个栗子：12345678910111213141516// 主函数function A(callback)&#123; callback() console.log('主函数')&#125; // 回调函数function B()&#123; setTimeout("console.log('回调函数')",2000)&#125;A(B)// 输出结果主函数回调函数20、谈谈你对盒模型的理解盒模型分为：标准盒模型和IE盒模型先来看看标准盒模型示例图W3C定义的盒子模型包括margin、border、padding、content ，元素的width=content的宽度再来看看IE盒模型IE盒子模型与W3C的盒子模型唯一区别就是元素的宽度，元素的width=content+padding+border21、谈谈px、em、rem的区别px是我们web开发中最用的单位，稳定精确，但当浏览器字体大小被改变时，页面布局可能被破坏em是相对于父元素设置的值，所以在使用em的时候一定要知道父元素的值计算公式：1 ÷ 父元素的font-size × 需要转换的像素值 = em值rem是CSS3的新单位，是相对于根元素html的值，他不像em那样依赖于父元素的字体大小，而造成混乱。22、说说你对cookie和session的理解cookies：cookies是由服务器发送给客户端（浏览器）的小量信息，以{key：value}的形式存在。客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。sessionsession是以服务端保存状态的。当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）；如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionIdsessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。23、判断数据类型的方法typeof123456typeof 123 //"number"typeof 'dsfsf' //"string"typeof false //"boolean"typeof function()&#123;console.log('aaa');&#125; //"function"typeof undefined //"undefined"typeof null //"object"instanceof12345123 instanceof Number, //false'dsfsf' instanceof String, //falsefalse instanceof Boolean, //false[1,2,3] instanceof Array, //truenull instanceof Object, //falseconstructor12var num = 123console.log(num.constructor==Number) // true使用toString()检测对象类型1234567var toString = Object.prototype.toString;toString.call(123); //"[object Number]"toString.call('abcdef'); //"[object String]"toString.call(true); //"[object Boolean]"toString.call(undefined); //"[object Undefined]"toString.call(null); //"[object Null]"24、谈谈你对html标签语义化的理解html标签分为有语义化标签和无语义化标签，举个栗子，table表示表格，就是有语义化标签，div就是无语义化标签。使用语义化标签可以让页面内容结构化，结构更清晰，便于代码的维护，利于SEO25、简要描述下JS有哪些内置的对象内置对象常用方法NumbertoString、valueOfBooleanStringcharAt、CharCodeAt、concat、indexOf、lastindexOf、replace、splitDategetDate、getDay、getFullYear、getHours、getTime、getMonthArrayabs、cos、sqrt26、 viewport常见设置都有哪些？1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"&gt;width：可视区域的宽度initial-scale：初始缩放比例,通过扩大或者缩小视觉视口的宽度实现maximum-scale：最大缩放比例minimun-scale：最小缩放比例user-scalable：是否允许用户进行缩放27、谈谈对冒泡事件的理解冒泡事件是由微软公司提出的，时间时间从子元素到父元素向上传递的过程。有时很我们并不需要父元素也能够触发事件，这也会引起事件错乱。阻止事件冒泡的方法：event.stopPropagation();12345$(function() &#123; $("#hr_three").click(function(event) &#123; event.stopPropagation(); &#125;);&#125;);return false12345$(function() &#123; $("#hr_three").click(function(event) &#123; return false; &#125;);&#125;);28、xml与html有什么区别？xml：可扩展标记语言(Extentsible Markup Language)html：超文本标记语言(Hyper Text Markup Language)html和xml只是结构上的相同，本质上有很大的区别的：html不区分大小写，xml严格区分大小写html标签都是预定义的，xml标签是自定义的可扩展html用于数据展示，xml用于数据的存储和传递参考来源29、重置（初始化）css的作用是什么？为了重置浏览器的默认样式，使得在各个浏览器中的样式尽量统一。常见的样式重置30、JS基本数据类型有几个？分别都是什么？六个，分别是：Number、Boolean、String、Null、Undefined、Symbol31、有几种前端存储的方式？这些方式的区别是什么？存储方式：cookies、localStorage、sessionStorage、Web SQL、IndexedDB区别：cookies: 在HTML5标准前本地存储的主要方式，优点是兼容性好，请求头自带cookies方便、缺点是大小只有4k，自动请求头加入cookies浪费流量，每个domain限制20个cookies，使用起来麻烦需要自行封装localStorage：HTML5加入的以键值对(key-value)为标准的方式，优点是操作方便，永久性存储(除非手动删除)，大小为5M，兼容IE8+sessionStorage：与localStorage基本类似，区别是sessionStorage当页面关闭后会被清理，而且与cookies、localStorage不同，它不能在所有同源窗口中共享，是会话级别的存储方式Web SQL：2010年被W3C废弃的本地数据库数据存储方案，但是主流浏览器(火狐除外)都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，用sql进行操作，当我们使用JavaScript时要进行转换，较为繁琐IndexedDB：是被正式纳入HTML5标准的数据库存储方案，它是NoSQL数据库，用键值对进行存储，可以进行快速读取操作，非常适合web场景，同时用JavaScript进行操作会非常方便。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星级评分组件（二）]]></title>
    <url>%2Fposts%2F7e0d1b42.html</url>
    <content type="text"><![CDATA[上次通过数据驱动实现了星级评价，后来我就思考能不能实现一个交互性更好一些的星级评价呢？于是就研究了一下，使用原生js实现了一个商城星级评分功能。在这个需求里主要实现的功能有：鼠标划过，所在星星和之前的星星全部变化，下方提示分数，鼠标移开，评分消失点击星星，所在星星和之前的星星全部变化，在星星后面显示分数点击之后，鼠标再次在星星上划过移开，不改变之前星星点击后的分数主要功能就是这样，下面代码实现。页面代码：12345678910111213&lt;div id="star"&gt; &lt;span&gt;评分&lt;/span&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 后面分数显示 --&gt; &lt;span&gt;&lt;/span&gt; &lt;!-- 下方分数提示 --&gt; &lt;p&gt;&lt;/p&gt;样式代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263body,div,ul,li,p &#123; margin: 0; padding: 0;&#125;body &#123; color: #666; font: 12px/1.5 Arial;&#125;ul &#123; list-style-type: none;&#125;#star &#123; position: relative; width: 600px; margin: 100px auto;&#125;#star ul,#star span &#123; float: left; display: inline; height: 19px; line-height: 19px;&#125;#star ul &#123; margin: 0 10px;&#125;#star li &#123; float: left; width: 24px; cursor: pointer; text-indent: -9999px; background: url(stars1.png) no-repeat;&#125;#star strong &#123; color: #f60; padding-left: 10px;&#125;#star li.on &#123; background-position: 0 -28px;&#125;#star p &#123; position: absolute; top: 20px; width: 159px; height: 60px; display: none; background: url(icon.gif) no-repeat; padding: 7px 10px 0;&#125;#star p em &#123; color: #f60; display: block; font-style: normal;&#125;最后是js代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546window.onload = function() &#123; var oStar = document.getElementById("star"); var aLi = oStar.getElementsByTagName("li"); var oUl = oStar.getElementsByTagName("ul")[0]; var oSpan = oStar.getElementsByTagName("span")[1]; var oP = oStar.getElementsByTagName("p")[0]; var i = iScore = iStar = 0; var aMsg = [ "很不满意|差得太离谱，与卖家描述的严重不符，非常不满", "不满意|部分有破损，与卖家描述的不符，不满意", "一般|质量一般，没有卖家描述的那么好", "满意|质量不错，与卖家描述的基本一致，还是挺满意的", "非常满意|质量非常好，与卖家描述的完全一致，非常满意" ] for (i = 1; i &lt;= aLi.length; i++) &#123; aLi[i - 1].index = i; //鼠标移过显示分数 aLi[i - 1].onmouseover = function() &#123; fnPoint(this.index); //浮动层显示 oP.style.display = "block"; //计算浮动层位置 oP.style.left = oUl.offsetLeft + this.index * this.offsetWidth - 104 + "px"; //匹配浮动层文字内容 oP.innerHTML = "&lt;em&gt;&lt;b&gt;" + this.index + "&lt;/b&gt; 分 " + aMsg[this.index - 1].match(/(.+)\|/)[1] + "&lt;/em&gt;" + aMsg[this.index - 1].match(/\|(.+)/)[1] &#125;; //鼠标离开后恢复上次评分 aLi[i - 1].onmouseout = function() &#123; fnPoint(); //关闭浮动层 oP.style.display = "none" &#125;; //点击后进行评分处理 aLi[i - 1].onclick = function() &#123; iStar = this.index; oP.style.display = "none"; oSpan.innerHTML = "&lt;strong&gt;" + (this.index) + " 分&lt;/strong&gt; (" + aMsg[this.index - 1].match(/\|(.+)/)[1] + ")" &#125; &#125; //评分处理 function fnPoint(iArg) &#123; //分数赋值 iScore = iArg || iStar; for (i = 0; i &lt; aLi.length; i++) aLi[i].className = i &lt; iScore ? "on" : ""; &#125;&#125;效果显示如下：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星级评分的实现]]></title>
    <url>%2Fposts%2F528833a6.html</url>
    <content type="text"><![CDATA[最近在做一个豆瓣电影的小程序demo，通过豆瓣API获取数据，再驱动视图，获取豆瓣数据显示星级评价这块收获蛮多，在这里记录下来。具体样式如下图红色框内所示：先从豆瓣获取数据：12345678910111213getMovieListData: function(url) &#123; var that = this; wx.request(&#123; url: url, method: 'GET', header: &#123; "content-type": "json", &#125;, success: function(res) &#123; console.log(res) &#125; &#125;)&#125;将获取的数据打印出来可以观察到星级指数与rating下的stars相关，stars数值都是5的倍数，五星是50。因此将数值转变为星星的个数，需要对数据进行处理:123456789101112131415function convertToStarsArray(stars) &#123; var num = stars.toString().substring(0, 1); var array = []; for (var i = 1; i &lt;= 5; i++) &#123; if (i &lt;= num) &#123; array.push(1); &#125; else &#123; array.push(0); &#125; &#125; if (stars % 10) &#123; array[num] = 2; &#125; return array;&#125;最后将处理的数据在页面呈现出来：123456789101112&lt;view class='stars-container'&gt;&lt;!-- 星级评分 --&gt; &lt;view class='stars'&gt; &lt;block wx:for='&#123;&#123;stars&#125;&#125;' wx:for-item="i" wx:key='key'&gt; &lt;image wx:if="&#123;&#123;i==1&#125;&#125;" src='/images/icon/star.png'&gt;&lt;/image&gt; &lt;image wx:elif="&#123;&#123;i==0&#125;&#125;" src='/images/icon/none-star.png'&gt;&lt;/image&gt; &lt;image wx:else src='/images/icon/half-star.png'&gt;&lt;/image&gt; &lt;/block&gt; &lt;/view&gt; &lt;!-- 分数显示区域 --&gt; &lt;text class='star-score'&gt;&#123;&#123;score&#125;&#125;&lt;/text&gt;&lt;/view&gt;大概思路和主要代码就是这样。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序收藏功能实现]]></title>
    <url>%2Fposts%2Fd112cad1.html</url>
    <content type="text"><![CDATA[话不多少，先看实现效果：该功能的实现用到的技术主要有_if-else，缓存，数据绑定_。通过缓存来判断收藏状态，将数据绑定到页面由if-else来判断对图片进行切换。代码示例：页面架构：12&lt;image wx:if="&#123;&#123;collected&#125;&#125;" catchtap='onCollectionTap' src='/images/icon/collection.png'&gt;&lt;/image&gt;&lt;image wx:else catchtap='onCollectionTap' src='/images/icon/collection-anti.png'&gt;&lt;/image&gt;逻辑代码：123456789101112131415161718192021222324252627282930onLoad: function (options) &#123; var postId = options.id; this.data.currentPostId = postId; var postsCollected = wx.getStorageSync('post_collected') if(postsCollected) &#123; // 缓存存在，将数据绑定到页面 var postCollected = postsCollected[postId]; if (postCollected)&#123; this.setData(&#123; collected: postCollected &#125;) &#125; &#125;else &#123; // 缓存不存在，设置缓存默认收藏状态为false var postsCollected = &#123;&#125;; postsCollected[postId] = false; wx.setStorageSync('post_collected', postsCollected) &#125; &#125;, onCollectionTap:function(event)&#123; var postsCollected = wx.getStorageSync('post_collected'); var postCollected = !postsCollected[this.data.currentPostId]; // 更新缓存值 postsCollected[this.data.currentPostId] = postCollected; wx.setStorageSync('post_collected', postsCollected); this.setData(&#123; collected: postCollected &#125;);]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2Fposts%2Fab688311.html</url>
    <content type="text"><![CDATA[简要介绍Flex（Flexible Layout Box Model：弹性布局盒模型）,是2009年w3c提出的一种可以简洁、快速弹性布局的属性。它能够更加高效方便控制元对齐排列，更重要的是能够自动计算元素的尺寸，无论这个元素的尺寸是固定的还是动态的主要思想是给予容器控制内部元素高度和宽度的能力。目前已得到主流浏览器支持，其中在webkit内核的浏览器中使用时，必须加上-webkit-前缀。如图所示，Flex布局存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。属性介绍容器属性以下6个属性是用在容器上的：123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-contentflex-direction属性flex-direction定义子元素在主轴的排列方向，换句话说它决定主轴的方向。它有4个值：1flex-direction: row | row-reverse | column | column-reverserow：默认值，从左往右，横向排列；row-reverse：从右往左，横向排列；column：从左往右，纵向排列；column-reverse：从右往左，纵向排列。flex-wrap属性flex-wrap属性定义，如果一条轴线排不下，如何换行。它有3个值：1flex-wrap: nowrap | wrap | wrap-reversenowrap：默认值，不换行；wrap：向下换行；wrap-reverse：向上换行。flex-flow属性这是一个复合属性是由flex-direction和flex-warp组合而成；justify-content属性justify-content定义子元素在主轴上的对齐模式，它有5个值：1justify-content: flex-start | flex-end | center | space-between | space-roundflex-start：默认值，左对齐；flex-end：右对齐；center：居中；space-between：两端对齐，项目之间的间隔都相等；space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。align-items属性align-items定义子元素在交叉轴上的对齐模式，它有5个值：1align-items: stretch | flex-start | flex-end | center | baselinestretch：默认值，如果项目未设置高度或设为auto，将占满整个容器的高度；flex-start：交叉轴的起点对齐;flex-end：交叉轴的终点对齐;center：交叉轴的中点对齐;baseline: 项目的第一行文字的基线对齐。align-content属性align-content定义控制容器内多行在交叉轴上的排列方式，它有6个值：1align-content: stretch | flex-start | flex-end | center | space-between | space-aroundstretch：默认值,轴线占满整个交叉轴;flex-start：与交叉轴的起点对齐;flex-end：与交叉轴的终点对齐;center：与交叉轴的中点对齐;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。项目属性Flex布局的项目属性也有6个123456orderflex-growflex-shrinkflex-basisflexalign-selforder属性order属性控制子元素出现在父容器的顺序，可以为0，任何整数，负数，数值越小，排列越靠前，默认为0。1order:&lt;number&gt;;当使用order时，其子元素都得设置排列的顺序，不能只对一个子项设置order,否则是无效的。flex-grow属性flex-grow–对父容器剩余的空间进行平均分配,不包括子元素自身所占据的空间。1flex-grow:&lt;number&gt;;默认为0，不会占据父容器剩余的空间；可以是整数和小数，不允许是负数。flex-shrink属性flex-shrink定义当父容器的空间不足时，对子元素进行比例压缩。1flex-shrink： 1 | &lt;number&gt; | 0;1： 默认值，父容器空间不足时，所有子元素对不足的空间平均分配，每个都承担一部分；：任意数字，但不能是负数；表示对该子元素压缩的比例；0： 所有子元素都不进行压缩，继续保持自身的宽高。flex-basis属性flex-basis属性用来设置伸缩子元素分配父元素剩余空间的分配方式1flex-basis： auto | [width] | 0;auto ： 默认值，以伸缩项目的默认尺寸计算；[width]： 可以是像素值、em、rem、百分比等；0 ： 忽略掉子元素的内容。flex属性flex属性是复合属性：1flex：-grow -shrink -basis;align-self属性align-self属性设置在交叉轴上对齐方式。1align-self： auto | flex-start | flex-end | center | baseline | stretch；auto： 默认值，以父容器的align-items为准；flex-start： 在交叉轴的开始位置；flex-end： 在交叉轴的终点位置；center： 在交叉轴的中间；baseline： 基线对齐；stretch： 在交叉轴拉伸对齐。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》笔记整理（五）]]></title>
    <url>%2Fposts%2Ff2777f54.html</url>
    <content type="text"><![CDATA[第九章 动态规划动态规划动态规划是一种解决棘手问题的方法，他将问题分成小问题，并先着手解决这些小问题。计算公式：CELL[i][j] = 两者中的较大值： 上一个单元格的值CELL[i-1][j] VS 当前商品的价值+剩余空间的价值CELL[i-1][j-当前商品的重量]动态规划的启示：动态规划可以在给定约束条件下找到最优解在问题可以分解为彼此独立且离散的问题时，就可以使用动态规划来解决每种动态规划解决方案都涉及网格单元格中的值通常就是你要优化的值每个单元格都是一个子问题绘制网格找出两个单词的最长公共子串：如果两个字母不相同，则值为0如果两个字母相同，值为左上角的值加1找出两个单词的最长公共子序列：如果两个字母不同，就选择上方和左方两个邻居中较大的那个如果两个字母相同，就将当前单元格的值设置为左上方单元格的值加1第十章 K最近邻算法K最近邻算法（k-nearesr neighbour，KNN），对东西进行分类时，可首先尝试这种算法。KNN主要用来做两项基本工作：分类和回归，分类就是编组；回归就是预测结果。在使用KNN时，需要挑选合适的特征，这决定KNN算法的成败。余弦相似度（ cosine similarity）余弦相似度不计算两个矢量的距离，而比较它们的角度。余弦相似度。余弦相似度被广泛用于协同过滤算法中，尤其是Item-base的协同过滤。余弦相似度衡量的是两个向量间的夹角大小，通过夹角的余弦值表示结果，假设A向量是（x1, y1），B向量是(x2, y2)，那么两个向量的余弦相似度为：分子为向量A与向量B的点乘，分母为二者各自的L2相乘，即将所有维度值的平方相加后开方。 余弦相似度的取值为[-1,1]，值越大表示越相似。机器学习KNN算法可用于机器学习的领域，除了创建推荐系统，，还有其他方面的应用：OCR指的是光学字符识别（ optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。 一般而言， OCR算法提取线段、点和曲线等特征。OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（ training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。创建垃圾邮件过滤器，圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（ Naive Bayes classifier）。预测股票市场]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》笔记整理（四）]]></title>
    <url>%2Fposts%2F9de9ba13.html</url>
    <content type="text"><![CDATA[第七章 狄克斯特拉算法广度优先搜素用于在非加权图图中查找最短路径；狄克斯特拉算法用于在加权图中查找最短路径。狄克斯特拉算法包含四个步骤：找出最便宜的节点；对于该节点的邻居，检查是否有前往它们的更短路径，如果有就更新其开销；重复这个过程直到对图中每个节点都这样做了；计算最终路径。狄克斯特拉算法用于每条边都要关联数字的图，这些数字称为权重。带权重的的图称为加权图，不带权重的图称为非加权图。图也可能有环，无向图意味着两个节点彼此指向对方，其实这就是环。狄克斯特拉算法只适用于有向无环图。如果有负权边就不能使用狄克斯特拉算法，要找出最短路径，可使用另一种算法，贝尔曼富的算法。代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def find_lowest_cost_node(costs,processed): lowest_cost = float("inf") lowest_cost_node = None for node in costs: cost = costs[node] if cost &lt; lowest_cost and node not in processed: lowest_cost = cost lowest_cost_node = node return lowest_cost_node def dijkstra(graph,costs,parents): processed = [] node = find_lowest_cost_node(costs,processed) while node is not None: cost=costs[node] neighbors=graph[node] for n in neighbors.keys(): new_cost = cost + neighbors[n] if costs[n]&gt;new_cost: costs[n]=new_cost parents[n]=node processed.append(node) node = find_lowest_cost_node(costs,processed) return costs,parents if __name__ == '__main__': graph = &#123;&#125; graph["start"] = &#123;&#125; graph["start"]["a"] = 6 graph["start"]["b"] = 6 graph["a"] = &#123;&#125; graph["a"]["fin"] = 1 graph["b"] = &#123;&#125; graph["b"]["a"] = 3 graph["b"]["fin"] = 5 graph["fin"] = &#123;&#125; infinity = float("inf") costs = &#123;&#125; costs["a"] = 6 costs["b"] = 2 costs["fin"] = infinity parents=&#123;&#125; parents["a"]="start" parents["b"] = "start" parents["fin"] = None costs,parents = dijkstra(graph,costs,parents) print(costs) #&#123;'a': 5, 'b': 2, 'fin': 6&#125; print(parents) #&#123;'a': 'b', 'b': 'start', 'fin': 'a'&#125;第八章 贪婪算法贪婪算法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。贪婪算法的优点是简单易行。近似算法在获得精确解需要的时间太长时间，可使用近似算法.判断近似算法的优劣如下：速度有多快得到的近似解和最优解的近似程度代码示例：1234567891011121314151617181920212223242526272829303132stations = &#123;&#125;stations["kone"] = set(["id", "nv", "ut"])stations["ktwo"] = set(["wa", "id", "mt"])stations["kthree"] = set(["or", "nv", "ca"])stations["kfour"] = set(["nv", "ut"])stations["kfive"] = set(["ca", "az"])print(stations)'''&#123;'kone': &#123;'id', 'nv', 'ut'&#125;,'ktwo': &#123;'wa', 'mt', 'id'&#125;,'kthree': &#123;'ca', 'or', 'nv'&#125;,'kfour': &#123;'nv', 'ut'&#125;,'kfive': &#123;'ca', 'az'&#125;&#125;''' states_needed = set(['id', 'or', 'ut', 'wa', 'ca', 'az', 'nv', 'mt'])print(states_needed) final_stations = set() while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = covered states_needed -= states_covered final_stations.add(best_station) print(final_stations) #&#123;'kfive', 'kthree', 'kone', 'ktwo'&#125; 选择1235NP完全问题NP完全问题的简单定义是：以难解著称的问题，如旅行商问题和集合覆盖问题，根本不可能编写出可快速解决这些问题的算法。要判断是不是NP完全问题很难，易于解决的问题和NP完全问题通常差别很小，以下是一些判断依据：元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常缓慢涉及“所有集合”的问题通常是NP完全问题不能将问题分成小问题，必须考虑各种情况的可能，这可能是NP完全问题如问题涉及序列且难以解决，它可能就是NP完全问题如问题涉及集合且难以解决，它可能就是NP完全问题如果问题可以转换为旅行商问题或者集合覆盖问题，那它肯定就是NP完全问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》笔记整理（三）]]></title>
    <url>%2Fposts%2F2ac4a376.html</url>
    <content type="text"><![CDATA[第五章 散列表散列函数散列函数是这样的函数，即无论你给他什么数据，他都还你一个数字。具体原因：散列函数总是将同样的输入映射到相同的索引散列函数将不同的输入映射到不同的索引散列函数知道数组有多大，只返回有效索引应用案例将散列表用于查找1234phone_book = &#123;&#125; #与phone_book = dick()等效phone_book["jenny"] = 7843643phone_book["emergency"] = 120print phone_book["emergency"] #120防止重复12345678voted = &#123;&#125;def check_voter(name): if vote.get(name): print &quot;kick them out&quot; else: vote[name] = True print &quot;let them vote&quot;将散列表用作缓存缓存的工作原理就是，网站将数据记住，而不再重新计算。它具有如下两个优点：用户能够更快的看到网页服务器需要做的工作更少缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中。散列表是无序的，因此添加键-值对的顺序无关紧要。冲突和性能散列函数总是将不同的键映射到数组的不同位置，然而实际上，几乎不可能编写初这样的散列函数。给两个键分配的位置相同，这种情况被称为冲突，处理冲突的方法很多，最简单的是，如果两个键映射到同一个位置，就在这个位置存储一个链表，但这会导致散列表的速度很慢。这里的经验教训有两个：散列函数很重要，最理想的情况是散列函数将键均匀的映射到散列表的不同位置如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长在平均情况下，散列表执行各种操作的时间都为O(1)，O(1)被称为常量时间，即无论散列表包含元素多少，从中取出数据时间都是相同的。在最糟情况下，散列表所有操作的运行时间都为O(n)。因此，在使用散列表时，避开最糟情况至关重要。为此避免冲突，需要有：较低的填装因子和良好的散列函数。填装因子很容易计算： 散列表包含的元素数/位置总数。一旦填装因子开始增大，就需要在散列表中添加位置，这杯成为调整长度，但是调整散列表的长度需要很长时间。一个不错的经验规则，一旦填装因子大于0.7，就调整散列表的长度、良好的散列函数让数组中的值呈均匀分布。第六章 广度优先搜索广度优先搜索你能够找出两样东西之间的最短距离。图图由节点和边组成。一个节点可能与众多节点直接相连，这些节点成为邻居。图用于模拟不同的东西是如何相连的.有向图中的边为箭头，箭头的方向指定了关系的方向；无向图中的边不带方向，其中的关系是双向的。如果renwuA依赖于renwuB，在列表中任务A就必须在任务B后面。这被称为拓扑排序，使用它可以根据图创建一个有序列表。树是一种特殊的图，它没有往后指的边。广度优先搜索解决最短路径的问题被称为广度优先搜索，它是一种用于图的查找算法，可帮助回答两类问题：从节点A出发，有通往节点B的路径吗从节点A出发，前往节点B的哪条路径最短广度优先搜索的运行时间为O(V+E)，其中V为顶点数，E为边数。代码示例：12345678910111213141516171819def person_is_seller(name): return name[-1] == 'm' def search(name): search_queue = deque()#创建对列 global graph search_queue += graph[name]#从谁开始搜索 searched = []#已经搜索，防止无限循环 while search_queue:#只要队列里有人 person = search_queue.popleft()#取出一人 if person not in searched: if person_is_seller(person): print(person+' is a mango seller') return True else: search_queue+=graph[person] searched.append(person) return False对于检查过的人务必不要再去检查，否则可能导致无限循环。队列广度优先搜索不仅查找从A到B的路径，而且找到的是最短路径，但只有按添加顺序查找时，才能实现这样的目的。队列就是一个可以实现这种目的的数据结构。队列只支持两种或操作：入队和出队。队列是一种先进先出(First In First Out,FIFO)的数据结构，栈是一种后进先出(Last In First Out,LIFO)的数据结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》笔记整理（二）]]></title>
    <url>%2Fposts%2F67da0024.html</url>
    <content type="text"><![CDATA[第三章 递归递归递归只是让解决方案更清晰，并没有实际上的优势，实际上，在有些情况下使用循环的性能更好。每个递归函数都有两个部分：基线条件和递归条件。递归条件指的是函数调用自己，二基线条件条件是函数不在调用自己，从而避免形成无限循环。代码示例：123456def countdown(i): print i if i &lt;= 0: #基线条件 return else: #递归条件 countdown(i-1)栈栈是一种简单的数据结构，他有两种操作：压入（插入）和弹出（删除并读取），插入的元素在最前面，读取的时候需要读取最上面的元素，并将其删除。计算机在内部使用被称为调用栈的栈。在调用函数时，计算机会将函数调用涉及的所有变量的值存储到内存中。当调用另一个函数时，当前函数暂停并处于未完成状态。栈在递归中扮演着重要的角色。虽然使用栈很方便呢，但也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机占用了大量的函数调用信息。这种情况下，有两种选择：重新编写代码使用循环 或者 使用尾递归。第四章 快速排序分而治之分而治之(divide and conquer， D&amp;C)一种著名的递归式解决方法。D&amp;C算法是递归的，使用D&amp;C解决问题过程包含两个步骤：（1）找出基线条件，这种条件必须尽可能简单（2）不断将问题分解（或者说缩小规模），知道符合基线条件。D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。二分朝招也是一种分而治之算法。编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。快速排序快速排序是一个重要的D&amp;C算法，它比选择排序快得多快速排序的工作原理：首先从数组中选出一个元素，这个元素被称为基准值，接下来找出比基准值小的元素和比基准值大的元素，这被称为分区，对这两个子数组进行快速排序。代码示例：123456789def quicksort(array): if len(array) &lt; 2: return array else: pivot = array[0] less = [i for i in array[1:] if i &lt;= pivot] greater = [i for i in array[1:] if i &gt; pivot] return quicksort(less) + [pivot] + quicksort(greater)print quicksort([10, 5, 2, 3])大O表示法快速排序法的独特之处在于，其速度取决于选择的基准值还有一种名为合并排序的排序算法，其运行时间为O(nlogn)，比选择排序快得多。快速排序在最糟糕的情况下，其运行时间为O(n²)。在大O表示法O(n)中，n实际上指c*n,c是算法所需要的固定时间量，被称为常量。大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在；但是在简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(logn)的速度比O(n)快得多。快速排序的性能高度依赖于选择的基准值。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》笔记整理（一）]]></title>
    <url>%2Fposts%2F57ccecfc.html</url>
    <content type="text"><![CDATA[第一章 算法简介二分查找二分查找是一种算法，其输入睡一个有序的元素列表，如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。一般而言，对于包含n个元素的列表，用二分查找最多需要㏒₂n步，而简单查找最多需要n步。二分查找python实现：12345678910111213141516def binary_search(list, item): low = 0 high = len(list)—1 while low &lt;= high: #只要范围没有缩小到只包含一个元素，就检查中间的元素 mid = (low + high) guess = list[mid] if guess == item: #找到了元素 return mid if guess &gt; item: #猜的数字大了 high = mid - 1 else: #猜的数字小了 low = mid + 1 return None #没有指定的元素my_list = [1, 3, 5, 7, 9]print binary_search(my_list, 3) # =&gt; 1print binary_search(my_list, -1) # =&gt; None二分查找的运行时间为对数时间或者叫做㏒时间，简单查找的运行时间为线性时间。大O表示法大O表示法是一种特殊的表示法，指出来算法的速度有多快。算法的运行时间以不同的速度增加。假设列表包含n个元素，简单查找需要检查每个元素，因此需要执行n次操作，使用大O表示法这个运行时间为O(n)。大O表示法指的并非以秒为单位的速度，它指出了算法运行时间的增速，让你能够比较操作数。一些常见的大O运行时间O(logn)，也叫对数时间，这样的算法包括二分查找O(n)，也叫线性查找，这样的算法包括简单查找O(n*logn)，这样的算法包括快速排序，一种速度较快的排序算法O(n²)，这样的算法包括选择排序，一种速度较慢的排序算法O(n！)，这样的算法包括旅行商问题的解决方案，一种非常慢的算法第二章 选择排序数组和链表将数据存储到内存时，需要请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方法——数组和链表，但他们并非都适用于所有情形。链表链表中的元素可以存储在内存任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串连在一起。使用链表的=时候，根本不需要移动元素，只要有足够的内存空间，就能为链表分配内存。链表的优势在插入元素方面。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。数组使用数组意味着所有你待办事项在内存中都是相连的，紧靠在一起的，这将浪费内存在数组中你知道每个元素的位置，需要随机的读取元素时，数组的效率很高，因为可以迅速找到数组的任何元素当需要在中间插入元素时，链表是更好的选择。在删除元素时，链表也是更好的选择，因为只要修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素向前移。不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能将元素删除。需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个的读取元素。链表只能顺序访问，要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可以直接跳到第十个元素。数组读取速度更快因为它支持随机访问。选择排序代码示例12345678910111213141516def findSmallest(arr): smallest = arr[0] smallest_index = 0 for i in range(1, len(ar if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_indexdef selectionSort(arr): #对数组进行排序 newArr = [] for i in range(len(arr)): smallest = findSmallest(arr) newArr.append(arr.pop(smallest)) return newArrprint selectionSort([5, 3, 6, 2, 10])]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用教程]]></title>
    <url>%2Fposts%2F56ed55c1.html</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，可以有效、高速地处理项目版本管理。SVN和Git的区别SVN是集中式版本控制系统，有一个中央服务器，干活的时候，用的都是自己的电脑，需要先从中央服务器获取最新的版本，然后开始干活，干完活了，再把自己的修改推动给中央服务器。缺点：需要联网的情况下才能使用，上传速度慢。Git是分布式版本控制系统，分布式版本控制系统没有中央服务器，每个人的电脑上都用一个完整的版本库，只要交换对方的修改就行，把各自的修改推送给对方。分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。优点：安全性高，不需要联网Git安装从Git官网选择对应的版本下载安装。常用命令新建代码库12345678在当前目录新建一个Git代码库$ git init新建一个目录，将其初始化为Git代码库$ git init [project-name]下载一个项目和它的整个代码历史$ git clone [url]配置123456789显示当前的Git配置$ git config --list编辑Git配置文件$ git config -e [--global]设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;增删文件123456789101112131415161718192021 添加指定文件到暂存区$ git add [file1] [file2] ...添加指定目录到暂存区，包括子目录$ git add [dir]添加当前目录的所有文件到暂存区$ git add .添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交$ git add -p删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]代码提交123456789101112131415161718提交暂存区到仓库区$ git commit -m [message]提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a提交时显示所有diff信息$ git commit -v使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...分支管理12345678910111213141516171819202122232425262728293031323334353637383940列出所有本地分支$ git branch列出所有远程分支$ git branch -r列出所有本地分支和远程分支$ git branch -a新建一个分支，但依然停留在当前分支$ git branch [branch-name]新建一个分支，并切换到该分支$ git checkout -b [branch]新建一个分支，指向指定commit$ git branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]切换到指定分支，并更新工作区$ git checkout [branch-name]切换到上一个分支$ git checkout -建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]合并指定分支到当前分支$ git merge [branch]选择一个commit，合并进当前分支$ git cherry-pick [commit]删除分支$ git branch -d [branch-name]删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]标签管理1234567891011121314151617181920212223242526列出所有tag$ git tag新建一个tag在当前commit$ git tag [tag]新建一个tag在指定commit$ git tag [tag] [commit]删除本地tag$ git tag -d [tag]删除远程tag$ git push origin :refs/tags/[tagName]查看tag信息$ git show [tag]提交指定tag$ git push [remote] [tag]提交所有tag$ git push [remote] --tags新建一个分支，指向某个tag$ git checkout -b [branch] [tag]查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960显示有变更的文件$ git status显示当前分支的版本历史$ git log显示commit历史，以及每次commit发生变更的文件$ git log --stat搜索提交历史，根据关键词$ git log -S [keyword]显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]显示指定文件相关的每一次diff$ git log -p [file]显示过去5次提交$ git log -5 --pretty --oneline显示所有提交过的用户，按提交次数排序$ git shortlog -sn显示指定文件是什么人在什么时间修改过$ git blame [file]显示暂存区和工作区的差异$ git diff显示暂存区和上一个commit的差异$ git diff --cached [file]显示工作区与当前分支最新commit之间的差异$ git diff HEAD显示两次提交之间的差异$ git diff [first-branch]...[second-branch]显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;显示某次提交的元数据和内容变化$ git show [commit]显示某次提交发生变化的文件$ git show --name-only [commit]显示某次提交时，某个文件的内容$ git show [commit]:[filename]显示当前分支的最近几次提交$ git reflog远程同步1234567891011121314151617181920212223下载远程仓库的所有变动$ git fetch [remote]显示所有远程仓库$ git remote -v显示某个远程仓库的信息$ git remote show [remote]增加一个新的远程仓库，并命名$ git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]上传本地指定分支到远程仓库$ git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force推送所有分支到远程仓库$ git push [remote] --all撤销12345678910111213141516171819202122232425262728293031恢复暂存区的指定文件到工作区$ git checkout [file]恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]恢复暂存区的所有文件到工作区$ git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]重置暂存区与工作区，与上一次commit保持一致$ git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop]]></content>
      <categories>
        <category>Git使用教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
